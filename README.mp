代理模式

定义 ：
    代理模式是指为其他对象提供一种代理，以控制对这个对象的访问。
    是一种结构型设计模式，代理对象在客服端和目标对象之间起到中介作用
    适用于 保护目标对象、增强目标对象的场景下。

JDK Proxy实现原理
    1.拿到被代理类的引用，并通过反射获取它的所有接口；
    2.JDK Proxy类重新生成一个新的类并实现被代理的所有接口的方法；
    3.动态的生成Java代码，把增强逻辑加入到新生的代码中；
    4.编译生成新的Java代码的class文件
    5.加载到JVM并运行新的class，得到全新的类

CGLIb

    CGLib 动态代理执行代理方法效率之所以比 JDK 的高是因为 Cglib 采用了
    FastClass 机制，它的原理简单来说就是：为代理类和被代理类各生成一个
    Class，这个 Class 会为代理类或被代理类的方法分配一个 index(int 类型)。
    这个 index 当做一个入参，FastClass就可以直接定位要调用的方法直接进
    行调用，这样省去了反射调用，所以调用效率比 JDK动态代理通过反射调用高

    FastClass是在执行MethodProxy invoke\invokeSuper时生成得并放在缓存中。

CGLib和JDK动态代理对比
    JDK动态代理是实现了被代理对象得接口，CGLib是继承了被代理对象;
    JDK和CGLib都是在运行期生成字节码文件，JDK是直接写Class字节码，
    CGLib使用了ASM框架写Class字节码，CGLib代理实现更负责，生成代
    理类比JDK效率低;
    JDK调用代理方法，是通过反射机制调用，CGLib是通过FastClass机制
    直接调用方法，CGLib执行效率更高

代理模式的优缺点

    优点
        代理模式能将代理对象与真实被调用的目标对象分离
        一定程度上降低了系统的耦合，扩展性好
        可以起到保护目标对象的目的
        可以对目标对象的功能增强

    缺点
        代理模式会造成系统设计中类的数量增加
        在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢
        增加了系统的复杂度

Spring中的代理选择原则
    当Bean有实现接口时，Spring就会用JDK的动态代理；
    当Bean没有实现接口时，Spring选择CGLib；
    Spring可以通过配置强制使用CGLib，只需在Spring的配置文件中加入如下代码
    <aop:aspectj-autoproxy proxy-target-class="true"/>

为什么JDK动态代理中要求目标类实现的接口数量不能超过65535个？
    因为在class文件中，接口个数都是用4位16进制表示的，最大值是2的16次方-1

    由于Class文件中方法，字段等都需要引用CONSTAN_Utf8_info型常量来描述名称，
    所以CONSTAN_Utf8_info类型常量的最大长度也就是Java方法，字段名的最大长度。
    而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535.
    所以Java程序中如果定义了超过64KB英文字符的变量和方法名，将会无法编译。

    生成的代理类不得超过施加的任何限制在虚拟机的类上。 例如, VM 可能会限制
    类可以实现到65535的接口数;在在这种情况下, {@code 接口} 数组的大小不能
    超过65535。





